<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>promise学习</title>
    <url>/2022/03/04/promise/</url>
    <content><![CDATA[<h2 id="promise是什么？"><a href="#promise是什么？" class="headerlink" title="promise是什么？"></a>promise是什么？</h2><p> 我们为什么会用 promise？promise 是为了解决我们的什么问题呢？<br> promise是js中进行异步编程的新的解决方案。具体上来说，promise是一个构造函数，用来封装一个异步操作并可以获取其结果。</p>
<h2 id="promise-解决的问题"><a href="#promise-解决的问题" class="headerlink" title="promise 解决的问题"></a>promise 解决的问题</h2><h3 id="指向回调函数的方式更加灵活"><a href="#指向回调函数的方式更加灵活" class="headerlink" title="指向回调函数的方式更加灵活"></a>指向回调函数的方式更加灵活</h3><p> 如果我们必须在执行回调函数前进行定义，如果我们使用promise  我们就可以更加灵活的定义回调函数，我们可以在异步函数执行完后定义函数，也可以自定义时间</p>
<h3 id="支持链式调用，可以解决回调地狱问题"><a href="#支持链式调用，可以解决回调地狱问题" class="headerlink" title="支持链式调用，可以解决回调地狱问题"></a>支持链式调用，可以解决回调地狱问题</h3><p>地狱回调是什么呢？地狱回调是多个异步函数的嵌套，第一个异步函数的操作根据上一个异步函数的返回结果为条件，依次进行异步函数嵌套，这就导致了会回调地狱。不便阅读同时错误处理比较麻烦。但是依然会有回调问题，因此我们的最终方案是 async和 await 我们的根本目的是为了把异步操作变为同步操作。</p>
<h2 id="三种类型的回调函数"><a href="#三种类型的回调函数" class="headerlink" title="三种类型的回调函数"></a>三种类型的回调函数</h2><p>同步回调  不会放到回调队列中,立即执行<br>异步回调  会放到回调队列中,将来执行</p>
<h2 id="promise-的状态的改变"><a href="#promise-的状态的改变" class="headerlink" title="promise 的状态的改变"></a>promise 的状态的改变</h2><p>pending 变为 resolved ，pending  变为 rejected,只有这两种状态 ，一旦确定就不会发生改变.</p>
<h2 id="promise-流程图"><a href="#promise-流程图" class="headerlink" title="promise 流程图"></a>promise 流程图</h2><p><img src="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" alt="Alt text" title="optional title"></p>
<h2 id="promise中的api"><a href="#promise中的api" class="headerlink" title="promise中的api"></a>promise中的api</h2><pre><code>then    方法在原型对象上 是异步回调函数，他会等待状态的改变
catch   也是在原型对象上
finally 也是在原型对象上
all reject resolve  在构造函数上
</code></pre>
<h2 id="构造函数的实现"><a href="#构造函数的实现" class="headerlink" title="构造函数的实现"></a>构造函数的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">       <span class="comment">//立即同步执行执行器函数</span></span><br><span class="line">       <span class="keyword">const</span> self=<span class="built_in">this</span></span><br><span class="line">       self.status = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">       self.data = <span class="literal">undefined</span></span><br><span class="line">       self.callbacks = []</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">       <span class="comment">//  改变状态 保存value数据  如果有待执行的callback函数，立即异步执行回调函数 onresolved</span></span><br><span class="line">           <span class="keyword">if</span> (self.status !== <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">           &#125;</span><br><span class="line">           self.status = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line">           self.data = value</span><br><span class="line">           <span class="keyword">if</span> (self.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                   self.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">                   callbacksObj.onresolved(value)</span><br><span class="line">                   &#125;);</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (self.status !== <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">           &#125;</span><br><span class="line">           self.status = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">           self.data = value</span><br><span class="line">           <span class="keyword">if</span> (self.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                   self.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">                   callbacksObj.onrejected(reason)</span><br><span class="line">                   &#125;);</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果执行器抛出异常，promise 对象变为reject状态</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           executor(resolve, reject)</span><br><span class="line">       &#125; <span class="keyword">catch</span>(error)&#123;</span><br><span class="line">           reject(error)</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onresolved, onrejected</span>) </span>&#123; </span><br><span class="line">      <span class="comment">//假设当前还是pending状态，保存回调函数</span></span><br><span class="line">       <span class="keyword">const</span> self=<span class="built_in">this</span></span><br><span class="line">       self.callbacks.push(&#123;</span><br><span class="line">       onresolved,</span><br><span class="line">       onrejected</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onrejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 只要有一个失败都失败</span></span><br><span class="line">   <span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//  返回第一个完成的promise     </span></span><br><span class="line">   <span class="built_in">window</span>.Promise = <span class="built_in">Promise</span></span><br><span class="line">   &#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>
<p>要注意的是这里我们的this指向问题，对于promise中的this来说它指向实列对象，但是resolve中的this指向的是window。我们可以把this存起来就行了。<br>我们要考虑一种情况就是，我们的状态没确定时我们先指定回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p= <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         resolve(<span class="number">1</span>)</span><br><span class="line">     &#125;,<span class="number">100</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;onresolved1&quot;</span>,value)</span><br><span class="line">   &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;onrejected1&quot;</span>,reason)</span><br><span class="line">   &#125;)</span><br><span class="line">   p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;onresolved2&quot;</span>,value)</span><br><span class="line">   &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;onrejected2&quot;</span>,reason)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<p>当我们的状态已经指定时,我们在.then函数中定义方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status == <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    self.callbacks.push(&#123;</span><br><span class="line">        onresolved,</span><br><span class="line">        onrejected</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.status == <span class="string">&#x27;resolved&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onresolved(self.data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onrejected(self.data)</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="then-方法的实现"><a href="#then-方法的实现" class="headerlink" title="then 方法的实现"></a>then 方法的实现</h2><p>在这里我们讨论两种情况，then遇到的是 pending 或者是其他状态</p>
<p>我们的 then 函数会返回一个新的promise ，有三种情况<br>1.如果抛出异常，return的 promise 就会失败，reason就是error<br>2.如果回调函数返回不是promise，return的promise就会成功，value就是返回值<br>3.如果回调函数返回的是promise，return的promise结果就是这个promise的结果</p>
<p>关键代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> result = callback(self.PromiseResult) <span class="comment">// result获取回调函数执行(return)的结果</span></span><br><span class="line">       <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123; <span class="comment">// 3. 如果回调函数返回的是promise</span></span><br><span class="line">         result.then(resolve, reject) <span class="comment">// 简洁写法</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2. 如果回调函数返回的不是promise</span></span><br><span class="line">         resolve(result)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (error) &#123; <span class="comment">//1. 如果抛出异常</span></span><br><span class="line">       reject(error)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Promise-catch"><a href="#Promise-catch" class="headerlink" title="Promise.catch"></a>Promise.catch</h2><h2 id="Promise-resolve1"><a href="#Promise-resolve1" class="headerlink" title="Promise.resolve1"></a>Promise.resolve1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个成功/失败的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123; <span class="comment">// value是promise =&gt; 使用value的结果作为promise的结果</span></span><br><span class="line">      value.then(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// value不是promise =&gt; promise状态变为成功，数据是value</span></span><br><span class="line">      resolve(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 返回一个失败的promise</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     reject(reason)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++)&#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为 成功</span></span><br><span class="line">        resolve(value)</span><br><span class="line">      &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        reject(reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 声明计数变量</span></span><br><span class="line">    <span class="comment">// const values = []; // 保存每个成功promise结果的数组</span></span><br><span class="line">    <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length) <span class="comment">// 指定数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++)&#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 得知对象状态是成功</span></span><br><span class="line">        count++</span><br><span class="line">        <span class="comment">// 将当前promise对象成功的结果存入到数组中</span></span><br><span class="line">        values[i] = value</span><br><span class="line">        <span class="keyword">if</span> (count === promises.length) &#123; <span class="comment">//每个promise对象都成功</span></span><br><span class="line">          resolve(values) <span class="comment">// 修改函数状态</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>webrtc学习</title>
    <url>/2022/03/04/webrtc%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="1-什么是webRtc"><a href="#1-什么是webRtc" class="headerlink" title="1.什么是webRtc"></a>1.什么是webRtc</h1><p>他是一个实时通信技术，可以不借助第三方服务器建立p2p连接，实现实时数据交流，我们可以实现，实时视频通话，实时聊天，屏幕分享，和录屏，以及点到点的数据传输。webRtc是基于ICE协议框架，而实现ICE的技术有下面的技术组成。</p>
<h1 id="2-STUN-服务器"><a href="#2-STUN-服务器" class="headerlink" title="2.STUN 服务器"></a>2.STUN 服务器</h1><p>我们要了解的就是stun协议，对于我们大部分的计算机来说，我们并不会有公网IP,我们只能有一个私网IP,然后通过NAT,我们把我们的私有IP,映射到公网上，这也就导致了我们端到端之间并不能直接建立连接，而STUN 服务器可以给我们一个公网地址，我们就能建立p2p连接。</p>
<h1 id="3-sdp-协议"><a href="#3-sdp-协议" class="headerlink" title="3.sdp 协议"></a>3.sdp 协议</h1><p>我们两端进行连接后，我们需要协商彼此的设备信息，sdp协议中包含两个客户的设备信息</p>
<h1 id="我们来打造一个聊天室"><a href="#我们来打造一个聊天室" class="headerlink" title="我们来打造一个聊天室"></a>我们来打造一个聊天室</h1><p>我们的视频播放室的创建</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webRtc</tag>
      </tags>
  </entry>
  <entry>
    <title>源码学习</title>
    <url>/2022/03/05/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="vue-是什么"><a href="#vue-是什么" class="headerlink" title="vue 是什么"></a>vue 是什么</h2><p>vue 是什么？vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rkuohao = <span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>;</span><br><span class="line">   <span class="comment">// 步骤拆解</span></span><br><span class="line">   <span class="comment">// 1. 拿到模板</span></span><br><span class="line">   <span class="comment">// 2. 拿到数据 ( data )</span></span><br><span class="line">   <span class="comment">// 3. 将数据与模板结合, 得到 的是 HTML 元素 ( DOM 元素 )</span></span><br><span class="line">   <span class="comment">// 4. 放到页面中</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 拿到模板</span></span><br><span class="line">   <span class="keyword">let</span> tmpNode = <span class="built_in">document</span>.querySelector( <span class="string">&#x27;#root&#x27;</span> ); <span class="comment">// 元素拿到了 模板就是他了</span></span><br><span class="line">   <span class="comment">// 2  拿到数据 ( data )</span></span><br><span class="line">   <span class="keyword">let</span> data = &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;一个新name&#x27;</span></span><br><span class="line">     , <span class="attr">message</span>: <span class="string">&#x27;一个消息&#x27;</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. 将数据放到模板中( ??? )</span></span><br><span class="line">   <span class="comment">//  一般都是使用 递归</span></span><br><span class="line">   <span class="comment">// 在现在这个案例中 template 是 DOM 元素,</span></span><br><span class="line">   <span class="comment">// 在真正的 Vue 源码中是 DOM -&gt; 字符串模板 -&gt; VNode -&gt; 真正的 DOM</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">compiler</span>(<span class="params"> template, data </span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> childNodes = template.childNodes; <span class="comment">// 取出子元素</span></span><br><span class="line">     <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childNodes.length; i++ ) &#123;</span><br><span class="line">       <span class="keyword">let</span> type = childNodes[ i ].nodeType; <span class="comment">// 1 元素, 3 文本节点</span></span><br><span class="line">       <span class="keyword">if</span> ( type === <span class="number">3</span> ) &#123;</span><br><span class="line">         <span class="comment">// 文本节点, 可以判断里面是否有 &#123;&#123;&#125;&#125; 插值</span></span><br><span class="line">         <span class="keyword">let</span> txt = childNodes[ i ].nodeValue; <span class="comment">// 该属性只有文本节点才有意义</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 有没有双花括号??? </span></span><br><span class="line">         txt = txt.replace( rkuohao, <span class="function"><span class="keyword">function</span> (<span class="params"> _, g </span>) </span>&#123; <span class="comment">// replace 使用正则匹配一次 函数就会被调用一次</span></span><br><span class="line">                                                   <span class="comment">// 函数的 第 0 个参数 表示匹配到的内容</span></span><br><span class="line">                                                   <span class="comment">// 函数的 第 n 个参数 表示正则中的 第 n 组</span></span><br><span class="line">           <span class="keyword">let</span> key = g.trim(); <span class="comment">// 写在双花括号里面的 东西</span></span><br><span class="line">           <span class="keyword">let</span> value = data[ key ];</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将 &#123;&#123; xxxx &#125;&#125; 用这个 值替换</span></span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">         &#125; );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注意:  txt 现在和 DOM 元素是没有关系</span></span><br><span class="line">         childNodes[ i ].nodeValue = txt;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ( type === <span class="number">1</span> ) &#123;</span><br><span class="line">         <span class="comment">// 元素, 考虑它有没有子元素, 是否需要将其子元素进行 判断是否要插值</span></span><br><span class="line">         compiler( childNodes[ i ], data );</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 利用 模板生成一个 需要被渲染的 HTML 标签 ( 准 真正在页面中显示的 标签 )</span></span><br><span class="line">   <span class="keyword">let</span> generateNode = tmpNode.cloneNode( <span class="literal">true</span> ); <span class="comment">// 注意这里是 DOM 元素, 可以这么用</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// console.log( tmpNode );</span></span><br><span class="line">   compiler( generateNode, data ); <span class="comment">// 将 坑 替换掉</span></span><br><span class="line">   <span class="comment">// console.log( generateNode );</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们此时是没有生成 新的 template, 所以这里看到的 是直接在页面中就更新的数据, 因为 DOM 是引用类型</span></span><br><span class="line">   <span class="comment">// 这样做 模板就没有了</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. 将 渲染好的 HTML 加到页面中</span></span><br><span class="line">   root.parentNode.replaceChild( generateNode, root );</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 上面的思路有很大的问题:</span></span><br><span class="line">   <span class="comment">// 1. Vue 使用的 虚拟 DOM</span></span><br><span class="line">   <span class="comment">// 2. 只考虑了 单属性 ( &#123;&#123; name &#125;&#125; ), 而 Vue 中大量的使用层级 ( &#123;&#123; child.name.firstName &#125;&#125; )</span></span><br><span class="line">   <span class="comment">// 3. 代码没有整合</span></span><br></pre></td></tr></table></figure>
<h2 id="解决上面的问题"><a href="#解决上面的问题" class="headerlink" title="解决上面的问题"></a>解决上面的问题</h2><h3 id="我们解决一个问题"><a href="#我们解决一个问题" class="headerlink" title="我们解决一个问题"></a>我们解决一个问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JGVue</span>(<span class="params"> options </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 习惯: 内部的数据使用下划线 开头, 只读数据使用 $ 开头</span></span><br><span class="line">    <span class="built_in">this</span>._data = options.data;</span><br><span class="line">    <span class="built_in">this</span>._el = options.el;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备工作 ( 准备模板 )</span></span><br><span class="line">    <span class="built_in">this</span>._templateDOM = <span class="built_in">document</span>.querySelector( <span class="built_in">this</span>._el );</span><br><span class="line">    <span class="built_in">this</span>._parent = <span class="built_in">this</span>._templateDOM.parentNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染工作</span></span><br><span class="line">    <span class="built_in">this</span>.render()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 将模板 即 可数据, 得到 HTML 加到页面中 */</span></span><br><span class="line">  JGVue.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.compiler();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/** 编译 将 模板与数据结合 得到 真正的 DOM 元素 */</span></span><br><span class="line">  JGVue.prototype.compiler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> realHTMLDOM = <span class="built_in">this</span>._templateDOM.cloneNode( <span class="literal">true</span> ); <span class="comment">// 用 模板 拷贝 得到 一个 准 DOM</span></span><br><span class="line">    compiler( realHTMLDOM, <span class="built_in">this</span>._data );</span><br><span class="line">    <span class="built_in">this</span>.update( realHTMLDOM );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 将 DOM 的元素 放到页面中 */</span></span><br><span class="line">  JGVue.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"> real </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._parent.replaceChild( real, <span class="built_in">document</span>.querySelector( <span class="string">&#x27;#root&#x27;</span> ) );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 想想怎么用:</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="keyword">new</span> JGVue( &#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;jim&#x27;</span></span><br><span class="line">      , <span class="attr">message</span>: <span class="string">&#x27;info&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; );</span><br></pre></td></tr></table></figure>

<p>我们怎样把 真实dom 转化为虚拟dom,而虚拟dom怎样变为真实的dom<br>是为了提高性能</p>
<h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>使用递归来实现,跟二叉树的先序遍历很像</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为什么要使用虚拟 DOM? 性能</span></span><br><span class="line">   <span class="comment">// &lt;div /&gt; =&gt; &#123; tag: &#x27;div&#x27; &#125;</span></span><br><span class="line">   <span class="comment">// 文本节点 =&gt; &#123; tag: undefined, value: &#x27;文本节点&#x27; &#125;</span></span><br><span class="line">   <span class="comment">// &lt;div title=&quot;1&quot; class=&quot;c&quot; /&gt; =&gt; &#123; tag: &#x27;div&#x27;, data: &#123; title: &#x27;1&#x27;, class: &#x27;c&#x27; &#125; &#125;</span></span><br><span class="line">   <span class="comment">// &lt;div&gt;&lt;div /&gt;&lt;/div&gt; =&gt; &#123; tag: &#x27;div&#x27;, children: [ &#123; tag: &#x27;div&#x27; &#125; ] &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="title">constructor</span>(<span class="params"> tag, data, value, type </span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.tag = tag &amp;&amp; tag.toLowerCase();</span><br><span class="line">       <span class="built_in">this</span>.data = data;</span><br><span class="line">       <span class="built_in">this</span>.value = value;</span><br><span class="line">       <span class="built_in">this</span>.type = type;</span><br><span class="line">       <span class="built_in">this</span>.children = [];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     appendChild ( vnode ) &#123;</span><br><span class="line">       <span class="built_in">this</span>.children.push( vnode );</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 使用递归 来遍历 DOM 元素, 生成 虚拟 DOM</span></span><br><span class="line"><span class="comment">    * Vue 中的源码使用的 栈结构 , 使用栈存储 父元素来实现递归生成</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getVNode</span>(<span class="params"> node </span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> nodeType = node.nodeType;</span><br><span class="line">     <span class="keyword">let</span> _vnode = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">if</span> ( nodeType === <span class="number">1</span> ) &#123;</span><br><span class="line">       <span class="comment">// 元素</span></span><br><span class="line">       <span class="keyword">let</span> nodeName = node.nodeName;</span><br><span class="line">       <span class="keyword">let</span> attrs = node.attributes;</span><br><span class="line">       <span class="keyword">let</span> _attrObj = &#123;&#125;;</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.length; i++ ) &#123; <span class="comment">// attrs[ i ] 属性节点 ( nodeType == 2 )</span></span><br><span class="line">         _attrObj[ attrs[ i ].nodeName ] = attrs[ i ].nodeValue;</span><br><span class="line">       &#125;</span><br><span class="line">       _vnode = <span class="keyword">new</span> VNode( nodeName, _attrObj, <span class="literal">undefined</span>, nodeType );</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 考虑 node 的子元素</span></span><br><span class="line">       <span class="keyword">let</span> childNodes = node.childNodes;</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childNodes.length; i++ ) &#123;</span><br><span class="line">         _vnode.appendChild( getVNode( childNodes[ i ] ) ); <span class="comment">// 递归</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( nodeType === <span class="number">3</span> ) &#123;</span><br><span class="line"></span><br><span class="line">       _vnode = <span class="keyword">new</span> VNode( <span class="literal">undefined</span>, <span class="literal">undefined</span>, node.nodeValue, nodeType );</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> _vnode;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> root = <span class="built_in">document</span>.querySelector( <span class="string">&#x27;#root&#x27;</span> );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> vroot = getVNode( root );</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log( vroot );</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将 vNode 转换为真正的 DOM ( 作业 )</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">parseVNode</span>(<span class="params"> vnode </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>我们怎样把虚拟dom 转化为真实的dom</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为什么要使用虚拟 DOM? 性能</span></span><br><span class="line">  <span class="comment">// &lt;div /&gt; =&gt; &#123; tag: &#x27;div&#x27; &#125;</span></span><br><span class="line">  <span class="comment">// 文本节点 =&gt; &#123; tag: undefined, value: &#x27;文本节点&#x27; &#125;</span></span><br><span class="line">  <span class="comment">// &lt;div title=&quot;1&quot; class=&quot;c&quot; /&gt; =&gt; &#123; tag: &#x27;div&#x27;, data: &#123; title: &#x27;1&#x27;, class: &#x27;c&#x27; &#125; &#125;</span></span><br><span class="line">  <span class="comment">// &lt;div&gt;&lt;div /&gt;&lt;/div&gt; =&gt; &#123; tag: &#x27;div&#x27;, children: [ &#123; tag: &#x27;div&#x27; &#125; ] &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"> tag, data, value, type </span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.tag = tag &amp;&amp; tag.toLowerCase();</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">      <span class="built_in">this</span>.type = type;</span><br><span class="line">      <span class="built_in">this</span>.children = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    appendChild ( vnode ) &#123;</span><br><span class="line">      <span class="built_in">this</span>.children.push( vnode );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 使用递归 来遍历 DOM 元素, 生成 虚拟 DOM</span></span><br><span class="line"><span class="comment">   * Vue 中的源码使用的 栈结构 , 使用栈存储 父元素来实现递归生成</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getVNode</span>(<span class="params"> node </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nodeType = node.nodeType;</span><br><span class="line">    <span class="keyword">let</span> _vnode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ( nodeType === <span class="number">1</span> ) &#123;</span><br><span class="line">      <span class="comment">// 元素</span></span><br><span class="line">      <span class="keyword">let</span> nodeName = node.nodeName;</span><br><span class="line">      <span class="keyword">let</span> attrs = node.attributes;</span><br><span class="line">      <span class="keyword">let</span> _attrObj = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.length; i++ ) &#123; <span class="comment">// attrs[ i ] 属性节点 ( nodeType == 2 )</span></span><br><span class="line">        _attrObj[ attrs[ i ].nodeName ] = attrs[ i ].nodeValue;</span><br><span class="line">      &#125;</span><br><span class="line">      _vnode = <span class="keyword">new</span> VNode( nodeName, _attrObj, <span class="literal">undefined</span>, nodeType );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 考虑 node 的子元素</span></span><br><span class="line">      <span class="keyword">let</span> childNodes = node.childNodes;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childNodes.length; i++ ) &#123;</span><br><span class="line">        _vnode.appendChild( getVNode( childNodes[ i ] ) ); <span class="comment">// 递归</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( nodeType === <span class="number">3</span> ) &#123;</span><br><span class="line"></span><br><span class="line">      _vnode = <span class="keyword">new</span> VNode( <span class="literal">undefined</span>, <span class="literal">undefined</span>, node.nodeValue, nodeType );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _vnode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> root = <span class="built_in">document</span>.querySelector( <span class="string">&#x27;#root&#x27;</span> );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> vroot = getVNode( root );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 vNode 转换为真正的 DOM ( 作业 )</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">parseVNode</span>(<span class="params"> vnode </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 真实的 DOM</span></span><br><span class="line">    <span class="keyword">let</span> type = vnode.type;</span><br><span class="line">    <span class="keyword">let</span> _node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ( type === <span class="number">3</span> ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode( vnode.value ); <span class="comment">// 创建文本节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( type === <span class="number">1</span> ) &#123;</span><br><span class="line"></span><br><span class="line">      _node = <span class="built_in">document</span>.createElement( vnode.tag );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 属性</span></span><br><span class="line">      <span class="keyword">let</span> data = vnode.data; <span class="comment">// 现在这个 data 是键值对</span></span><br><span class="line">      <span class="built_in">Object</span>.keys( data ).forEach( <span class="function">(<span class="params"> key </span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> attrName = key;</span><br><span class="line">        <span class="keyword">let</span> attrValue = data[ key ];</span><br><span class="line">        _node.setAttribute( attrName, attrValue );</span><br><span class="line">      &#125; );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 子元素</span></span><br><span class="line">      <span class="keyword">let</span> children = vnode.children;</span><br><span class="line">      children.forEach( <span class="function"><span class="params">subvnode</span> =&gt;</span> &#123;</span><br><span class="line">        _node.appendChild( parseVNode( subvnode ) ); <span class="comment">// 递归转换子元素 ( 虚拟 DOM )</span></span><br><span class="line">      &#125; );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> _node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在真正的 Vue 中也是使用递归 + 栈 数据类型</span></span><br><span class="line">  <span class="keyword">let</span> dom2 = parseVNode( vroot );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要验证, 只要将转换后的 DOM 打印出来 看看与原来的 DOM 是不是一样</span></span><br><span class="line">  <span class="built_in">console</span>.log( dom2 );</span><br></pre></td></tr></table></figure>

<h3 id="我们解决第二个问题"><a href="#我们解决第二个问题" class="headerlink" title="我们解决第二个问题"></a>我们解决第二个问题</h3><p>数据具有层级属性  我们用到了迭代</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> paths = path.split( <span class="string">&#x27;.&#x27;</span> ); <span class="comment">// [ xxx, yyy, zzz ]</span></span><br><span class="line">     <span class="comment">// 先 取得 obj.xxx, 再取得 结果中的 yyy, 再取得 结果中的 zzz</span></span><br><span class="line">     <span class="comment">// let res = null;</span></span><br><span class="line">     <span class="comment">// res = obj[ paths[ 0 ] ];</span></span><br><span class="line">     <span class="comment">// res = res[ paths[ 1 ] ];</span></span><br><span class="line">     <span class="comment">// res = res[ paths[ 2 ] ];</span></span><br><span class="line">     <span class="keyword">let</span> res = obj;</span><br><span class="line">     <span class="keyword">let</span> prop;</span><br><span class="line">     <span class="keyword">while</span>( prop = paths.shift() ) &#123;</span><br><span class="line">       res = res[ prop ];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> o = &#123;</span><br><span class="line">     <span class="attr">a</span>: &#123;</span><br><span class="line">       <span class="attr">b</span>: &#123;</span><br><span class="line">         <span class="attr">c</span>: &#123;</span><br><span class="line">           <span class="attr">d</span>: &#123;</span><br><span class="line">             <span class="attr">e</span>: <span class="string">&#x27;正确了&#x27;</span></span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>


<h2 id="函数柯里化与渲染模型"><a href="#函数柯里化与渲染模型" class="headerlink" title="函数柯里化与渲染模型"></a>函数柯里化与渲染模型</h2><p>改良 JGVue, 抽取 combine, render, mount, mountComponent 等结构<br>我们为什么使用函数柯里化，提高性能，使柯里化可以缓存一部分的能力。<br>模板-&gt;ast<br>ast-&gt;vnode<br>vnode—&gt;dom<br>第一个最浪费时间，解析字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tags = <span class="string">&#x27;div,p,a,img,ul,li&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeMap</span>(<span class="params"> keys </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> set = &#123;&#125;; <span class="comment">// 集合</span></span><br><span class="line">    keys.forEach( <span class="function"><span class="params">key</span> =&gt;</span> set[ key ] = <span class="literal">true</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"> tagName </span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !!set[ tagName.toLowerCase() ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isHTMLTag = makeMap( tags ); <span class="comment">// 返回的函数</span></span><br></pre></td></tr></table></figure>

<p>我们前面写的内容每次渲染一次就会重新渲染。<br>我们的虚拟dom可以理解为抽象语法树。我们将虚拟dom缓存起来，复用虚拟dom<br>不解析模板，解析模板是很浪费时间的。</p>
<p>优化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 虚拟 DOM 构造函数 */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params"> tag, data, value, type </span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.tag = tag &amp;&amp; tag.toLowerCase();</span><br><span class="line">     <span class="built_in">this</span>.data = data;</span><br><span class="line">     <span class="built_in">this</span>.value = value;</span><br><span class="line">     <span class="built_in">this</span>.type = type;</span><br><span class="line">     <span class="built_in">this</span>.children = [];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   appendChild ( vnode ) &#123;</span><br><span class="line">     <span class="built_in">this</span>.children.push( vnode );</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/** 由 HTML DOM -&gt; VNode: 将这个函数当做 compiler 函数 */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getVNode</span>(<span class="params"> node </span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> nodeType = node.nodeType;</span><br><span class="line">   <span class="keyword">let</span> _vnode = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> ( nodeType === <span class="number">1</span> ) &#123;</span><br><span class="line">     <span class="comment">// 元素</span></span><br><span class="line">     <span class="keyword">let</span> nodeName = node.nodeName;</span><br><span class="line">     <span class="keyword">let</span> attrs = node.attributes;</span><br><span class="line">     <span class="keyword">let</span> _attrObj = &#123;&#125;;</span><br><span class="line">     <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.length; i++ ) &#123; <span class="comment">// attrs[ i ] 属性节点 ( nodeType == 2 )</span></span><br><span class="line">       _attrObj[ attrs[ i ].nodeName ] = attrs[ i ].nodeValue;</span><br><span class="line">     &#125;</span><br><span class="line">     _vnode = <span class="keyword">new</span> VNode( nodeName, _attrObj, <span class="literal">undefined</span>, nodeType );</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 考虑 node 的子元素</span></span><br><span class="line">     <span class="keyword">let</span> childNodes = node.childNodes;</span><br><span class="line">     <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childNodes.length; i++ ) &#123;</span><br><span class="line">       _vnode.appendChild( getVNode( childNodes[ i ] ) ); <span class="comment">// 递归</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( nodeType === <span class="number">3</span> ) &#123;</span><br><span class="line"></span><br><span class="line">     _vnode = <span class="keyword">new</span> VNode( <span class="literal">undefined</span>, <span class="literal">undefined</span>, node.nodeValue, nodeType );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> _vnode;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> rkuohao = <span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>;</span><br><span class="line"> <span class="comment">/** 根据路径 访问对象成员 */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getValueByPath</span>(<span class="params"> obj, path </span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> paths = path.split( <span class="string">&#x27;.&#x27;</span> ); <span class="comment">// [ xxx, yyy, zzz ]</span></span><br><span class="line">   <span class="keyword">let</span> res = obj;</span><br><span class="line">   <span class="keyword">let</span> prop;</span><br><span class="line">   <span class="keyword">while</span>( prop = paths.shift() ) &#123;</span><br><span class="line">     res = res[ prop ];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/** 将 带有 坑的 Vnode 与数据 data 结合, 得到 填充数据的 VNode: 模拟 AST -&gt; VNode */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params"> vnode, data </span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> _type = vnode.type;</span><br><span class="line">   <span class="keyword">let</span> _data = vnode.data;</span><br><span class="line">   <span class="keyword">let</span> _value = vnode.value;</span><br><span class="line">   <span class="keyword">let</span> _tag = vnode.tag;</span><br><span class="line">   <span class="keyword">let</span> _children = vnode.children;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> _vnode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ( _type === <span class="number">3</span> ) &#123; <span class="comment">// 文本节点 </span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对文本处理</span></span><br><span class="line">     _value = _value.replace( rkuohao, <span class="function"><span class="keyword">function</span> (<span class="params"> _, g </span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getValueByPath( data, g.trim() );</span><br><span class="line">     &#125; );</span><br><span class="line"></span><br><span class="line">     _vnode = <span class="keyword">new</span> VNode( _tag, _data, _value, _type )</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( _type === <span class="number">1</span> ) &#123; <span class="comment">// 元素节点</span></span><br><span class="line">     _vnode = <span class="keyword">new</span> VNode( _tag, _data, _value, _type );</span><br><span class="line">     _children.forEach( <span class="function"><span class="params">_subvnode</span> =&gt;</span> _vnode.appendChild( combine( _subvnode, data ) ) );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> _vnode;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">JGVue</span>(<span class="params"> options </span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>._data = options.data;</span><br><span class="line">   <span class="built_in">this</span>._template = <span class="built_in">document</span>.querySelector( options.el ); <span class="comment">// vue 是字符串, 这里是 DOM </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.mount(); <span class="comment">// 挂载</span></span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> JGVue.prototype.mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 需要提供一个 render 方法: 生成 虚拟 DOM</span></span><br><span class="line">   <span class="built_in">this</span>.render = <span class="built_in">this</span>.createRenderFn()</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.mountComponent();</span><br><span class="line"> &#125;</span><br><span class="line"> JGVue.prototype.mountComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 执行 mountComponent() 函数 </span></span><br><span class="line">   <span class="keyword">let</span> mount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.update( <span class="built_in">this</span>.render() )</span><br><span class="line">   &#125;</span><br><span class="line">   mount.call( <span class="built_in">this</span> ); <span class="comment">// 本质应该交给 watcher 来调用, 但是还没有讲到这里</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在真正的 Vue 中使用了 二次提交的 设计结构</span></span><br><span class="line"><span class="comment">  * 1. 在 页面中 的 DOM 和 虚拟 DOM 是一一对应的关系</span></span><br><span class="line"><span class="comment">  * 2. 先 有 AST 和 数据 生成 VNode ( 新, render )</span></span><br><span class="line"><span class="comment">  * 3. 将 就的 VNode 和 新的 VNode 比较 ( diff ), 更新 ( update )</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 这里是生成 render 函数, 目的是缓存 抽象语法树 ( 我们使用 虚拟 DOM 来模拟 )</span></span><br><span class="line"> JGVue.prototype.createRenderFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> ast = getVNode( <span class="built_in">this</span>._template );</span><br><span class="line">   <span class="comment">// Vue: 将 AST + data =&gt; VNode</span></span><br><span class="line">   <span class="comment">// 我们: 带有坑的 VNode + data =&gt; 含有数据的 VNode</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 将 带有 坑的 VNode 转换为 待数据的 VNode</span></span><br><span class="line">     <span class="keyword">let</span> _tmp = combine( ast, <span class="built_in">this</span>._data );</span><br><span class="line">     <span class="keyword">debugger</span>;</span><br><span class="line">     <span class="keyword">return</span> _tmp;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将虚拟 DOM 渲染到页面中: diff 算法就在里</span></span><br><span class="line"> JGVue.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 简化, 直接生成 HTML DOM replaceChild 到页面中</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> app = <span class="keyword">new</span> JGVue( &#123;</span><br><span class="line">   <span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">   <span class="attr">data</span>: &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">     , <span class="attr">age</span>: <span class="number">19</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125; );</span><br><span class="line"></span><br><span class="line"> app.name = <span class="string">&#x27;李四&#x27;</span>; <span class="comment">// 这个赋值已完成, 页面数据就更新</span></span><br></pre></td></tr></table></figure>


<p>箭头函数的指向问题<br>指向的是所在作用域指向的对象</p>
<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 o 提供属性</span></span><br><span class="line">o.name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( o, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: !<span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">  <span class="attr">value</span>: <span class="number">19</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// get 和 set 上</span></span><br><span class="line"><span class="comment">// 要响应式就表示在赋值和读取的时候, 附带的要做一些事情</span></span><br><span class="line"><span class="keyword">let</span> _gender;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( o, <span class="string">&#x27;gender&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">  get () &#123; <span class="comment">// 如果使用 o.gender 来访问数据, 就会调用 get 方法 ( getter, 读取器 )</span></span><br><span class="line">    <span class="keyword">return</span> _gender;</span><br><span class="line">  &#125;,</span><br><span class="line">  set ( newVal ) &#123; <span class="comment">// 如果 o.gender = &#x27;xxx&#x27;, 那么就会调用 这个 set 方法, 并设置的值会最为参数传入 set</span></span><br><span class="line">    <span class="comment">// console.log( &#x27;赋值的新值为: &#x27;, newVal );</span></span><br><span class="line">    _gender = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果同时使用 get 和 set 需要一个中间变量存储真正的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题: 这个 _gender 被暴露在全局作用域???? 怎么办???</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Vue 使用 defineRective( target, key, value, enumerable )</span></span><br></pre></td></tr></table></figure>

<p>数组的常用方法：<br>pop<br>push<br>sort<br>reverse<br>splice</p>
<h2 id="拦截数组的方法"><a href="#拦截数组的方法" class="headerlink" title="拦截数组的方法"></a>拦截数组的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ARRAY_METHOD = [</span><br><span class="line">     <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;reverse&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">   ];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 思路, 原型式继承: 修改原型链的结构</span></span><br><span class="line">   <span class="keyword">let</span> arr = [];</span><br><span class="line">   <span class="comment">// 继承关系: arr -&gt; Array.prototype -&gt; Object.prototype -&gt; ...</span></span><br><span class="line">   <span class="comment">// 继承关系: arr -&gt; 改写的方法 -&gt; Array.prototype -&gt; Object.prototype -&gt; ...</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> array_methods = <span class="built_in">Object</span>.create( <span class="built_in">Array</span>.prototype );</span><br><span class="line"></span><br><span class="line">   ARRAY_METHOD.forEach( <span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">     array_methods[ method ] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 调用原来的方法</span></span><br><span class="line">       <span class="built_in">console</span>.log( <span class="string">&#x27;调用的是拦截的 &#x27;</span> + method + <span class="string">&#x27; 方法&#x27;</span> );</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将数据进行响应式化</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">let</span> res = <span class="built_in">Array</span>.prototype[ method ].apply( <span class="built_in">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">       <span class="comment">// Array.prototype[ method ].call( this, ...arguments ); // 类比</span></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; );</span><br><span class="line"></span><br><span class="line">   arr.__proto__ = array_methods;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Vue 的源码中也做了判断</span></span><br><span class="line">   <span class="comment">// 如果 浏览器支持 __proto__ 那么他就这么做</span></span><br><span class="line">   <span class="comment">// 如果不支持, vue 使用的是混入法</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// arr.length = 0</span></span><br></pre></td></tr></table></figure>

<p>这里有原型的借用</p>
<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>c数据结构</title>
    <url>/2022/03/05/c%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。 二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树 。我对二叉树的掌握包括二叉树的增加，删除，和排序。</p>
<h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="comment">//树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//树根</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* root;</span><br><span class="line">&#125; Tree;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//创建树--插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Tree* tree, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个节点，让左右指针全部指向空，数据为value</span></span><br><span class="line">    Node* node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = value;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//判断树是不是空树，如果是，直接让树根指向这一个结点即可</span></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        tree-&gt;root = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//不是空树</span></span><br><span class="line">        Node* temp = tree-&gt;root;<span class="comment">//从树根开始</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; temp-&gt;data)&#123; <span class="comment">//小于就进左儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    temp-&gt;left = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//继续往下搜寻</span></span><br><span class="line">                    temp = temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则进右儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    temp-&gt;right = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">//继续往下搜寻</span></span><br><span class="line">                    temp = temp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//树的中序遍历 In-order traversal</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;data);</span><br><span class="line">        inorder(node-&gt;left);</span><br><span class="line">        inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Tree tree;</span><br><span class="line">    tree.root = <span class="literal">NULL</span>;<span class="comment">//创建一个空树</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">//输入n个数并创建这个树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        insert(&amp;tree, temp);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    inorder(tree.root);<span class="comment">//中序遍历  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>1.先序遍历</p>
<p>2.中序遍历</p>
<p>3.后序遍历</p>
<p>4.层次遍历</p>
<pre><code class="C">
</code></pre>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>electron本地阅读器</title>
    <url>/2022/03/06/electron%E6%9C%AC%E5%9C%B0%E9%98%85%E8%AF%BB%E5%99%A8/</url>
    <content><![CDATA[<h2 id="electron-是什么？"><a href="#electron-是什么？" class="headerlink" title="electron 是什么？"></a>electron 是什么？</h2><p>Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2022/03/06/webpack/</url>
    <content><![CDATA[<p>第一小节<br>我们为什么要学习webpack<br>为了解决作用域问题<br>实现代码拆分  也就是require 模块化使用，但是在浏览器上不能使用</p>
<p>安装webpack</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i webpack webpack-cli</span><br></pre></td></tr></table></figure>

<p>运行 webpack</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure>

<p> 自定义webpack 配置
 </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>js执行上下文</title>
    <url>/2022/03/10/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h1 id="什么时执行上下文？"><a href="#什么时执行上下文？" class="headerlink" title="什么时执行上下文？"></a>什么时执行上下文？</h1><p>执行上下文就是js代码执行的环境。</p>
<p>而且执行上下文分为三种类型</p>
<h2 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h2><p>这是默认的执行上下文，我们的代码在全局执行，这时我们会创建一个全局对象，并且设置 this，this隐式绑定在全局对象上。</p>
<h2 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h2><p>但我们的函数被调用时，我们的函数会创建一个函数执行上下文，它可以有任意个。</p>
<h2 id="eval-执行上下文"><a href="#eval-执行上下文" class="headerlink" title="eval() 执行上下文"></a>eval() 执行上下文</h2><p>不常用可做了解</p>
<h2 id="执行上下文是怎样被创建出来的呢？"><a href="#执行上下文是怎样被创建出来的呢？" class="headerlink" title="执行上下文是怎样被创建出来的呢？"></a>执行上下文是怎样被创建出来的呢？</h2><p>分为创建阶段 和执行阶段<br>创建阶段 创建词法环境组件 和 创建变量环境组件</p>
<p>词法环境就是标识符和变量映射的结构<br>标识符指的是函数的名字和变量 而变量是对实际对象或者原始数据的引用</p>
<p>当全局上下文执行时<br>我们会创建词法环境组件 和 变量环境组件</p>
<p>而这种两种环境组件中包含三个部分</p>
<p>环境记录（environment） 外部（outer） 和 （thisBinding)</p>
<p>从执行上下文来理解  闭包 变量提升 和 作用域链</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>css学习</title>
    <url>/2022/03/05/css%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="布局方式"><a href="#布局方式" class="headerlink" title="布局方式"></a>布局方式</h2><p>浮动布局<br>定位布局<br>relative  absolute  fixed  </p>
<p>flex 布局</p>
<p>gide 布局<br>我们常见的几种布局效果</p>
<p>双飞翼布局   </p>
<p>圣杯布局</p>
<p>可以通过float flex 以及 grid 实现</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/13/electron/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>布局</title>
    <url>/2022/03/14/%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>js数据结构</title>
    <url>/2022/03/10/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>创建一个栈<br>new stack</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>new q</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js数据结构</tag>
      </tags>
  </entry>
</search>
